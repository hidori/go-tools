package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path"
	"strings"

	"github.com/hidori/go-tools/genprop"
	"github.com/pkg/errors"
	"golang.org/x/tools/imports"
)

const (
	tagName   = "genprop"
	doNotEdit = "// Code generated by github.com/hidori/go-tools/cmd/" + tagName + " DO NOT EDIT."
)

const (
	exitCodeError = 1
	exitCodeUsage = 2
)

var initialismFlag = flag.String("initialism", "id,url,api", "names to which initialism should be applied")

func main() {
	flag.Parse()

	args := flag.Args()
	if len(args) != 1 {
		fmt.Fprintf(os.Stdout, "usage: %s [OPTION]... <FILE>\n\noption(s):\n", path.Base(os.Args[0]))
		flag.PrintDefaults()
		os.Exit(exitCodeUsage)
	}

	err := run(config(), args[0], os.Stdout)
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(exitCodeUsage)
	}
}

func config() *genprop.GeneratorConfig {
	return &genprop.GeneratorConfig{
		TagName:    tagName,
		Initialism: strings.Split(*initialismFlag, ","),
	}
}

func run(config *genprop.GeneratorConfig, fileName string, writer io.Writer) error {
	f, err := parser.ParseFile(token.NewFileSet(), fileName, nil, parser.AllErrors)
	if err != nil {
		return errors.Wrap(err, "fail to parser.ParseFile()")
	}

	generator := genprop.NewGenerator(config)

	fset := token.NewFileSet()

	decls, err := generator.Generate(fset, f)
	if err != nil {
		return errors.Wrap(err, "fail to generator.Generate()")
	}

	buffer := bytes.NewBuffer([]byte{})

	err = format.Node(buffer, fset, &ast.File{
		Name:  ast.NewIdent(f.Name.Name),
		Decls: decls,
	})
	if err != nil {
		return errors.Wrap(err, "fail to format.Node()")
	}

	output, err := imports.Process("<genprop>", buffer.Bytes(), &imports.Options{
		FormatOnly: false,
	})
	if err != nil {
		return errors.Wrap(err, "fail to imports.Process()")
	}

	_, _ = fmt.Fprintln(writer, doNotEdit)
	_, _ = writer.Write(output)

	return nil
}
