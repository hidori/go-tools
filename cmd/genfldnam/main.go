package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path"

	"github.com/hidori/go-tools/genfldnam"
	"github.com/pkg/errors"
)

const (
	tagName   = "genfldnam"
	doNotEdit = "// Code generated by github.com/hidori/go-tools/cmd/" + tagName + " DO NOT EDIT."
)

const (
	exitCodeError = 1
	exitCodeUsage = 2
)

var (
	packageFlag        = flag.String("package", "", "package name")
	skewerFlag         = flag.String("skewer", "FieldName", "skewer of the variable name storing a field name")
	allNamesFlag       = flag.Bool("all-names", false, "enable output slices storing all field names")
	allNamesSuffixFlag = flag.String("all-names-suffix", "AllFieldNames", "suffix of the slice name storing all field names")
)

func main() {
	flag.Parse()

	args := flag.Args()
	if len(args) != 1 {
		fmt.Fprintf(os.Stdout, "usage: %s [OPTION]... <FILE>\n\noption(s):\n", path.Base(os.Args[0]))
		flag.PrintDefaults()
		os.Exit(exitCodeUsage)
	}

	err := run(os.Stdout, args[0])
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(exitCodeError)
	}
}

func run(writer io.Writer, fileName string) error {
	f, err := parser.ParseFile(token.NewFileSet(), fileName, nil, parser.AllErrors)
	if err != nil {
		return errors.Wrap(err, "fail to parser.ParseFile()")
	}

	generator := genfldnam.NewGenerator(config())

	decls, err := generator.Generate(token.NewFileSet(), f)
	if err != nil {
		return errors.Wrap(err, "fail to generator.Generate()")
	}

	packageName := f.Name.Name
	if *packageFlag != "" {
		packageName = *packageFlag
	}

	err = output(writer, decls, packageName)
	if err != nil {
		return errors.Wrap(err, "fail to output()")
	}

	return nil
}

func config() *genfldnam.GeneratorConfig {
	return &genfldnam.GeneratorConfig{
		TagName:        tagName,
		Skewer:         *skewerFlag,
		AllNames:       *allNamesFlag,
		AllNamesSuffix: *allNamesSuffixFlag,
	}
}

func output(writer io.Writer, decls []ast.Decl, packageName string) error {
	buffer := bytes.NewBuffer([]byte{})
	fmt.Fprintln(buffer, doNotEdit)

	err := format.Node(buffer, token.NewFileSet(), &ast.File{
		Name:  ast.NewIdent(packageName),
		Decls: decls,
	})
	if err != nil {
		return errors.Wrap(err, "fail to format.Node()")
	}

	_, _ = writer.Write(buffer.Bytes())

	return nil
}
